 // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 1 : Success()
    @Test
    public void testFetchNotifyDetailsByEventId_Success() {
        // Mock the eventId
        String eventId = "123";

        // Mock the eventNotifies
        List<DmEventNotify> eventNotifies = Collections.emptyList();

        // Stub the mock repository to return eventNotifies when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.of(eventNotifies));

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertTrue(result.isPresent()); // Check if the result is present (not empty)

        EventResponse eventResponse = result.get(); // Get the actual EventResponse object

        assertNotNull(eventResponse); // Check if the EventResponse is not null
        assertNotNull(eventResponse.getEventDataResponse()); // Check if EventDataResponse is not null
        assertFalse(eventResponse.getEventDataResponse().getEventNotifyResponses().isEmpty()); // Check if the list of EventNotifyResponses is not empty
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 2 : Optional.of - EmptyEventResponse()
    @Test
    public void testFetchNotifyDetailsByEventId_EmptyEventResponse() {
        // Mock the eventId
        String eventId = "123";          // the variable eventId is being initialized

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = eventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assert
        assertFalse(result.isPresent());            // Check if the result is not present (empty)
    }

    
    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 3 : NotFound()
    @Test
    public void testFetchNotifyDetailsByEventId_NotFound() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock, the repository to return an empty result when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 4 : InternalServerError() --> InternalServerError()
    @Test
    public void testFetchNotifyDetailsByEventId_InternalServerError() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock, the repository to throw an exception when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenThrow(new RuntimeException("Database error"));

        // Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Handle the exception or assert accordingly
        assertFalse(result.isPresent()); // or handle the exception appropriately
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 5 : InvalidEventId()  --> Incorrect
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_InvalidEventId() {
        // Mock the eventId
        String eventId = "invalid"; // Invalid eventId

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = eventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventDataResponse());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 6 : EventIdIsNull()
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_EventIdIsNull() {
        // Mock the eventId
        String eventId = null;    // Set eventId as null

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 7 : EventIdIsEmpty()
    @Test
    public void testFetchNotifyDetailsByEventIdEmpty_EventIdIsEmpty() {
        // Mock the eventId
        String eventId = " ";     // Set eventId as empty string

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.empty());

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

    // Method 5 : fetchNotifyDetailsByEventId
    // Scenario 8 : NoEventNotifies()
    @Test
    public void fetchNotifyDetailsByEventId_NoEventNotifies() {
        // Mock the eventId
        String eventId = "123";

        // Stub the mock repository to return an empty Optional when findByEventId is called
        when(dmEventNotifyRepository.findByEventId(Long.parseLong(eventId))).thenReturn(Optional.of(Collections.emptyList()));

        // Act, Call the service method
        Optional<EventResponse> result = documentGeneratorEventStoreService.fetchNotifyDetailsByEventId(eventId);

        // Assertions
        assertFalse(result.isPresent());
    }

//-------------------------------------------------------------------------------------------------------------------------------------------

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 1 : Success()
    @Test
    public void testFetchEventSummaryByDateRange_Success() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 2 : TypeIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsEmpty() {
        // Mock input parameters
        String type = ""; // Empty type
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 3 : TypeIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsNull() {
        // Mock input parameters
        String type = null; // Type is null
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 4 : StartDateIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateIsEmpty() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = ""; // Empty startDate
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 5 : StartDateIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateIsNull() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = null; // StartDate is null
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 6 : EndDateIsEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_EndDateIsEmpty() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = ""; // Empty endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 7 : EndDateIsNull()
    @Test
    public void testFetchEventSummaryByDateRange_EndDateIsNull() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = null; // EndDate is null

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 8 : AllInputsAreEmpty()
    @Test
    public void testFetchEventSummaryByDateRange_AllInputsAreEmpty() {
        // Mock input parameters
        String type = ""; // Empty type
        String startDate = ""; // Empty startDate
        String endDate = ""; // Empty endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 9 : AllInputsAreNull()
    @Test
    public void testFetchEventSummaryByDateRange_AllInputsAreNull() {
        // Mock input parameters
        String type = null; // Null type
        String startDate = null; // Null startDate
        String endDate = null; // Null endDate

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 10 : InvalidDateRange()
    @Test
    public void testFetchEventSummaryByDateRange_InvalidDateRange() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-10"; // End date is before start date
        String endDate = "2023-01-01";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // The result should be an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 11 : EmptyDBEvents()
    @Test
    public void testFetchEventSummaryByDateRange_EmptyDBEvents() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> emptyDBEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertEquals(0, result.get().getEventControlResponse().getEventControlDatas().size());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 12 : EmptyDBCounts()
    @Test
    public void testFetchEventSummaryByDateRange_EmptyDBCounts() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> emptyDBCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(emptyDBCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertEquals(0, result.get().getEventControlResponse().getEventControlDatas().size());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 13 : TypeIsInvalid() or type = "12345";
    @Test
    public void testFetchEventSummaryByDateRange_TypeIsInvalid() {
        // Mock input parameters
        String type = "invalidType"; // Type is something other than "reconcile"
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertFalse(result.isPresent()); // Expecting an empty Optional
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 14 : StartDateAndEndDateBothSame()
    @Test
    public void testFetchEventSummaryByDateRange_StartDateAndEndDateBothSame() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-10";
        String endDate = "2023-01-10"; // Same as startDate

        // Mock the behavior of dmEventRepository
        when(dmEventRepository.findEventsByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(any(LocalDate.class), any(LocalDate.class)))
                .thenReturn(new ArrayList<>());

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent()); // Expecting a non-empty Optional
        assertNotNull(result.get());
        assertNotNull(result.get().getEventControlResponse());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 15 : NoEventSummary() or NoEventSummaryByDateRange()
    @Test
    public void testFetchEventSummaryByDateRange_NoEventSummary() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNotNull(result.get().getEventControlResponse());
        assertNotNull(result.get().getEventControlResponse().getEventControlDatas());
        assertTrue(result.get().getEventControlResponse().getEventControlDatas().isEmpty());
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 16 : InternalServerError()
    @Test
    public void testFetchEventSummaryByDateRange_InternalServerError() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);

        // Stub the repository methods to throw an exception
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenThrow(new RuntimeException("Internal Server Error"));

        // Call the service method
        assertThrows(RuntimeException.class, () -> eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate));
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 17 : NoEventControlResponse()
    @Test
    public void testFetchEventSummaryByDateRange_NoEventControlResponse() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);
        List<Map<String, Object>> dbEvents = new ArrayList<>();
        List<Map<String, Object>> dbCounts = new ArrayList<>();

        // Stub the repository methods
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbEvents);
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(dbCounts);

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isPresent());
        assertNull(result.get().getEventControlResponse());   // No event control data is retrieved
    }

    // Method 6 : fetchNotifyDetailsByEventId
    // Scenario 18 : NotFound()
    @Test
    public void testFetchEventSummaryByDateRange_NotFound() {
        // Mock input parameters
        String type = "reconcile";
        String startDate = "2023-01-01";
        String endDate = "2023-01-10";

        // Mock data for the repository
        LocalDate dateStart = LocalDate.parse(startDate);
        LocalDate dateEnd = LocalDate.parse(endDate);

        // Stub the repository methods to return empty lists
        when(dmEventRepository.findEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());
        when(dmEventRepository.findDocumentEventsByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());
        when(dmEventRepository.findTotalEventCountByStartDateAndEndDate(dateStart, dateEnd)).thenReturn(new ArrayList<>());

        // Call the service method
        Optional<EventSummaryResponse> result = eventStoreService.fetchEventSummaryByDateRange(type, startDate, endDate);

        // Assertions
        assertTrue(result.isEmpty());    // To simulate a "Not Found" scenario.
    }




// 7th method
// Testing that it should fetch document by input ID successfully when document is found
// Test case 1

    @Test
    void shouldFetchDocumentByInputIdSuccessfullyWhenDocumentIsFound() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Create a valid document object
        Document document = new Document();
        document.setCustomerAccountUuid(customerAccountUuid);
        document.setInputId(inputId);

// Simulate the successful retrieval of the document and method returns a valid Document object
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenReturn(Optional.of(document));

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertTrue(eventResponse.isPresent());
        assertEquals(HttpStatus.OK, eventResponse.get().getStatusCode());
    }

    private Optional<EventResponse> fetchDocumentByInputId(UUID customerAccountUuid, String inputId) {
        return null;
    }

// Testing that it should return empty optional object when document is not found
// Test case 2

    @Test
    void shouldReturnEmptyOptionalObjectWhenDocumentIsNotFound() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Simulate the unsuccessful retrieval of the document
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenReturn(Optional.empty());

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertFalse(eventResponse.isPresent());
    }

// Throw exception when customer account UUID is invalid
// Test case 3

    @Test
    void shouldThrowExceptionWhenCustomerAccountUuidIsInvalid() {
// Create an invalid customer account UUID
        UUID customerAccountUuid = UUID.randomUUID();

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, "my-input-id");

// Assert the results(If the code throws the expected exception, the assertion will pass. If the code does not throw the expected exception, the assertion will fail)
        assertThrows(IllegalArgumentException.class, () -> eventResponse.get());
    }

// Throw exception when input ID is invalid
// Test case 4

    @Test
    void shouldThrowExceptionWhenInputIdIsInvalid() {
// Create an invalid input ID
        String inputId = null;

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(UUID.randomUUID(), inputId);

// Assert the results
        assertThrows(IllegalArgumentException.class, () -> eventResponse.get());
    }

// Test that the method returns a valid `EventResponse` object when the customer account UUID and input ID are valid and the document is found in the database, even if the document is deleted.
// Test case 5

    @Test
    void shouldFetchDocumentByInputIdSuccessfullyWhenDocumentIsDeleted() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Create a valid document object and set its deleted flag to true
        Document document = new Document();
        document.setCustomerAccountUuid(customerAccountUuid);
        document.setInputId(inputId);
        document.setDeleted(true);

// Simulate the successful retrieval of the document
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenReturn(Optional.of(document));

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertTrue(eventResponse.isPresent());
        assertEquals(HttpStatus.OK, eventResponse.get().getStatusCode());
    }

// Test that the method returns an empty `Optional` object when the customer account UUID is valid but the input ID is null.
// Test case 6

    @Test
    void shouldReturnEmptyOptionalObjectWhenInputIdIsNull() {
// Create a valid customer account UUID
        UUID customerAccountUuid = UUID.randomUUID();

// Call the fetchDocumentByInputId() method with a null input ID
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, null);

// Assert the results
        assertFalse(eventResponse.isPresent());
    }

// Test that the method returns an empty `Optional` object when the customer account UUID is null.
// Test case 7

    @Test
    void shouldReturnEmptyOptionalObjectWhenCustomerAccountUuidIsNull() {
// Call the fetchDocumentByInputId() method with a null customer account UUID
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(null, "my-input-id");

// Assert the results(assertion should pass if the eventResponse object is not present)
        assertFalse(eventResponse.isPresent());
    }

// Test that the method returns a 500 status code when the `documentRepository.findByCustomerAccountUuidAndInputId()` method throws an exception.
// Test case 8

    @Test
    void shouldReturn500StatusCodeWhenDocumentRepositoryThrowsException() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Simulate the `documentRepository.findByCustomerAccountUuidAndInputId()` method throwing an exception
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenThrow(new RuntimeException());

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertFalse(eventResponse.isPresent());
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, eventResponse.get().getStatusCode());
    }

// Test that the method returns a valid `EventResponse` object when the customer account UUID and input ID are valid and the document is found in the database, even if the document is expired
// Test case 9

    @Test
    void shouldFetchDocumentByInputIdSuccessfullyWhenDocumentIsExpired() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Create a valid document object and set its expired flag to true
        Document document = new Document();
        document.setCustomerAccountUuid(customerAccountUuid);
        document.setInputId(inputId);
        document.setExpired(true);

// Simulate the successful retrieval of the document
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenReturn(Optional.of(document));

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertTrue(eventResponse.isPresent());
        assertEquals(HttpStatus.OK, eventResponse.get().getStatusCode());
    }


// Test that the method returns a 404 status code when the customer account UUID and input ID are valid but the document is not found in the database.
// Test case 10

    @Test
    void shouldReturn404StatusCodeWhenDocumentIsNotFound() {
// Create a valid customer account UUID and input ID
        UUID customerAccountUuid = UUID.randomUUID();
        String inputId = "my-input-id";

// Simulate the unsuccessful retrieval of the document
        when(documentRepository.findByCustomerAccountUuidAndInputId(customerAccountUuid, inputId))
                .thenReturn(Optional.empty());

// Call the fetchDocumentByInputId() method
        Optional<EventResponse> eventResponse = documentGeneratorEventStoreService.fetchDocumentByInputId(customerAccountUuid, inputId);

// Assert the results
        assertFalse(eventResponse.isPresent());
        assertEquals(HttpStatus.NOT_FOUND, eventResponse.get().getStatusCode());
    }

